Название метода: Гармонический поиск (Harmony Search)
Историческая справка
В 2001 году Geem разработал и предложил свой алгоритм гармонического поиска (Harmony Search, или HS). Некоторые авторы заявляют, что навеян данный алгоритм был игрой джаз-музыкантов, другие говорят, что в основе лежит просто процесс создания приятной мелодии. Это и легло в основу алгоритма.
Находит как глобальный, так и локальный минимум в зависимости от начальный данных:
•	Локальный: Если начальная точка или гармония находится близко к локальному минимуму, алгоритм может застрять в этом локальном минимуме, особенно если параметры алгоритма (например, коэффициент гармонического поиска или "HMCR") настроены так, что процесс склоняется к более детализированным локальным решениям.
•	Глобальный: Метод имеет возможность избежать застревания в локальных минимумах, особенно если он использует случайные элементы в процессе поиска (параметр PAR) и этот параметр хорошо настроен.
Типы функций: многомерные, негладкие, функциями как непрерывной, так и дискретной оптимизации 
Плюсы:
•	Простота (как реализации, так и понимания);
•	Достаточно малое количество настраиваемых параметров и наличие рекомендаций по выбору параметров;
•	Является методом нулевого порядка (отпадает необходимость численного дифференцирования);
•	Метод легко и удобно встраивается в другие методы (например, в меметические алгоритмы, или в качестве дополнительного контура генетического алгоритма).
Минусы:
•	Низкая скорость сходимости;
•	Плохо применим для решения задач больших размерностей из-за простоты составляющих
Алгоритм метода:
Шаг 1. 
Инициализация алгоритма. Задать параметры метода:
- hms - размер памяти гармонии;
- hmcr - частоту выбора значений из памяти гармонии;
- par - частоту выбора соседнего значения;
- fw - вектор максимального изменения приращения;
- K - максимальное число итераций.
Положить число итераций k = 0.
Шаг 2. 
Формирование начального множества решений. На множестве допустимых решений генерировать hms решений x1, ..., xhm. Найти соответствующие значения целевой функции f(xl), ..., f(xhms). Сохранить их в памяти гармонии (НМ):
 
Найти наихудшее решение в памяти xworst.
Шаг 3. 
Генерация нового решения. Сгенерировать новый вектор xnew. Для всех i = 1, ..., n выполнить следующее.
	3.1. Получить значения хi’ следующим образом:
	- с вероятностью hmcr выбрать элемент из памяти НМ с номером 
int [u (0,1) * hms] +1:
xi’ = xiint [u (0,1) * hms] +1
где u (0,1) - равномерно распределенное число от 0 до 1; int [*] - операция нахождения целой части числа;
- с вероятностью 1 - hmcr выбрать значение внутри промежутка [ai, bi]: xi’ ϵ [ai, bi] 
	3.2. Если значение хi’ выбрано из памяти, то:
	- с вероятностью par найти
	xinew = xi’ + fwi * u (-1,1)
где и (-1,1) - равномерно распределенное число на [-1,1]; - с вероятностью 1 - par положить 
xinew = xi’
Шаг 4. 
Обновление памяти гармонии. Если новое решение xnew лучше наихудшего решения xworst в памяти, то заменить xworst на xnew. Если иначе - не заменять.
Шаг 5. 
Проверка условий окончаний процесса поиска:
- если k < K - 1, положить k = k +1 и перейти к шагу 3;
- если k = K - 1, процесс завершить.
Шаг 6. Найти наилучшее решение xbest в памяти, положить x* = xbest
Модификации метода
Чтобы устранить недостатки HS, Махдави предложил новый вариант HS, названный Improved Harmony Search (IHS). IHS динамически обновляет PAR в соответствии со следующим уравнением:
 
Где PAR(t) -  частоту выбора соседнего значения для поколения t, PARmin-минимальная частоту выбора соседнего значения, PARmax-максимальная частоту выбора соседнего значения, t – номер поколения. 
Кроме того, fw динамически обновляется следующим образом: 
 
bw- вектор максимального изменения приращения для поколения t, bwmin- минимальный вектор максимального изменения приращения, bwmax-максимальный вектор максимального изменения приращения. Тестовый пример 
